#!/usr/bin/env python
#    _____ _     ____  ____  ____  ____  _____
#   /    // \   /  _ \/  __\/  _ \/  __\/__ __\
#   |  __\| |   | / \||  \/|| / \||  \/|  / \
#   | |   | |_/\| |-|||  __/| \_/||    /  | |
#   \_/   \____/\_/ \|\_/   \____/\_/\_\  \_/
#
"""git-reset | gitr:

small fzf-based CLI utility for easy 'git-reset'

"""

import sys
from subprocess import PIPE, CalledProcessError, Popen, call, check_output


def fzf(list_in, prompt):
    proc = Popen(
        [
            "fzf",
            "--no-multi",
            "--layout=reverse",
            "--height=60%",
            f"--header={prompt}",
            "--bind=j:down,k:up,l:toggle,h:toggle,space:toggle,ctrl-j:preview-down,ctrl-k:preview-up",
            "--preview-window=right:wrap",
            '--preview=git show --color=always $(echo {} | sed "s/ .*//")',
        ],
        stdin=PIPE,
        stdout=PIPE,
    )
    stdout, _ = proc.communicate(input="\n".join(list_in).encode())
    if proc.returncode != 0:
        return None
    return stdout.decode().strip()


def git_log(complete=True):
    flags = []
    if not complete:
        flags += ["--abbrev-commit", "--oneline"]
    try:
        return check_output(["git", "log"] + flags)[:-1].decode().split("\n")
    except CalledProcessError:
        return []


if __name__ == "__main__":
    short_log = git_log(complete=False)
    value = fzf(short_log, "git reset")
    if value is None:
        sys.exit(1)
    flags = []
    if len(sys.argv) > 1 and sys.argv[1] == "--hard":
        flags += ["--hard"]
    status = call(["git", "reset", value.split(" ")[0]] + flags)
    sys.exit(status)
